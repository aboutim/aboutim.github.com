<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[virtualization-tech-comparison]]></title>
    <url>%2F2017%2F08%2F23%2Fvirtualization-tech-comparison%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[使用 PowerCLI 批量获取 VMX 并注册到 VC 清单中]]></title>
    <url>%2F2017%2F07%2F17%2Fpowecli-register-datastore-vmx%2F</url>
    <content type="text"><![CDATA[适合场景 存储搬迁到别的机房，VM 计划性停机，使用需要批量的把 VM 注册到新机房的计算资源池中。 适合找出没有注册到VC指定位置中的非活动 VM 思路 获取 Datastore 的信息 ，示例是获取集群内的 Datastore 1$Datastoreinfo = Get-Datastore -Nmae &apos;DatastoreName&apos; | %&#123;Get-View $_.Id&#125; 处理 Datastore 的信息 1$DsBrowser = Get-View $Datastoreinfo.browser 新建搜索对象，附加搜索条件 123$SearchSpec = New-Object VMware.Vim.HostDatastoreBrowserSearchSpec$SearchSpec.matchpattern = &quot;*.vmx&quot;$DsPath = &quot;[&quot; + $Datastoreinfo.Name + &quot;]&quot; 搜索并展现 1$SearchResult = $DsBrowser.SearchDatastoreSubFolders($DsPath, $SearchSpec) | where &#123;$_.FolderPath -notmatch &quot;.snapshot&quot;&#125; | %&#123;$.FolderPath + ($_.File | select Path).Path&#125; 最终输出的结果为 1[datastorename] VMnameFolder/VMname.vmx 注册VM 1New-VM -Name $VMname -VMFilePath $VMXpath -ResourcePool $vmhost -Location $VMFolder -RunAsync *如果 VM 名称曾经修改过，又没有做过 XvMotion (storeger vMotion) VMnameFolder以及目录下所有的VM文件，还是原来旧的 VMname 命名。 扩展 可套用 foreach 循环，对多个 Datastore 进行检索VMX文件 如果是场景1，可在 VM 是注册状态下，使用 PowerCLI 直接获取 VMX_PATH 路径以及对应的 VMname，位置信息等，导出为表，将来可使用 PowerCLI 根据表的信息进行注册。]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>PowerCLI</tag>
        <tag>VMWare运维</tag>
        <tag>VMX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 vCSA 6.0 vphere-web-client-页面无法打开]]></title>
    <url>%2F2016%2F11%2F15%2Fvcsa-web-client-svc%2F</url>
    <content type="text"><![CDATA[故障描述5.5 版本 VMWare 就提倡用 web-client ，但是 web-client 的响应时间以及被动刷新真的很让人捉急，因此大部分人还是喜欢用 vsphere-client for desktop 。前端发现web-client无法打开，但是：5480 后台以及引导页面还是可以打开的。也就是https://#you-vc# /vsphere-client/?csp初步估计是 VC 的 web 服务异常了 排错解决SSH 上去 check 一下 vcsa:~ # /etc/init.d/vsphere-client status VMware vSphere Web Client is running: PID:14701, Wrapper:STARTED, Java:STARTED 正在运行，但页面就是打不开。重启服务试试 vcsa:~ # /etc/init.d/vsphere-client restart 等一分钟左右，刷新页面，登录界面出来了 除此之外，遇到别的异常可考虑重启对应的功能模块来尝试解决修复 vCSA 服务列表 服务名称 描述 applmgmt VMware Appliance Management Service vmware-cis-license VMware License Service vmware-cm VMware Component Manager vmware-eam VMware ESX Agent Manager vmware-sts-idmd VMware Identity Management Service vmware-invsvc VMware Inventory Service vmware-mbcs VMware Message Bus Configuration Service vmware-netdumper VMware vSphere ESXi Dump Collector vmware-perfcharts VMware Performance Charts vmware-rbd-watchdog VMware vSphere Auto Deploy Waiter vmware-rhttpproxy VMware HTTP Reverse Proxy vmware-sca VMware Service Control Agent vmware-sps VMware vSphere Profile-Driven Storage Service vmware-stsd VMware Security Token Service vmware-syslog VMware Common Logging Service vmware-syslog-health VMware Syslog Health Service vmware-vapi-endpoint VMware vAPI Endpoint vmware-vdcs VMware Content Library Service vmafdd VMware Authentication Framework vmcad VMware Certificate Service vmdird VMware Directory Service vmware-vpostgres VMware Postgres vmware-vpx-workflow VMware vCenter Workflow Manager vmware-vpxd VMware vCenter Server vmware-vsm VMware vService Manager vsphere-client vSphere Web Client vmware-vws VMware System and Hardware Health Manager vmware-vsan-health VMware vSAN Health Service 其它命令运行以下命令以列出 vCenter Server Appliance 服务： service-control –list 要查看 vCenter Server Appliance 服务的当前状态，请键入以下命令： service-control –status 运行以下命令以启动特定服务： service-control –startservicename 也可以键入以下命令启动所有服务： service-control –start –all 要执行该命令的预演，请将–dry-run选项添加到该命令。此时将显示该命令将运行哪些操作，而不执行这些操作。例如，键入以下命令： service-control –start –all –dry-run 运行以下命令以停止特定服务： service-control –stopservicename 也可以键入以下命令停止所有服务： service-control –stop –all 要执行该命令的预演，请将–dry-run选项添加到该命令。此时将显示该命令将运行哪些操作，而不执行这些操作。例如，键入以下命令： service-control –stop –all –dry-run 也可以键入以下命令停止所有服务： service-control –stop –all 运行以下命令以启动特定服务： service-control –startservicename 也可以键入以下命令启动所有服务： service-control –start –all 服务列表以及其它命令来自官方 KB2115730]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>VCSA</tag>
        <tag>排障</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[另类方式实现 VCS5.5 安全有效地"升级"至 vCSA6.0]]></title>
    <url>%2F2016%2F10%2F13%2Fvc5-upto-vcsa6%2F</url>
    <content type="text"><![CDATA[常规升级方式VCS (vCenter Server for Windows)平滑升级到 vCSA (vCenter Server Appliance) ？ 对不起，这种操作在6.0之前 官方文档是不存在的。VCS 是运行在 Windows 之上的虚拟化管理程序，而 vCSA 是运行在 Linux 上的，且是由 VMWare 定制开发好的appliance ，这也是 vCSA 的 A。两者的管理功能在6.0后几乎一样，但却是使用的底层操作系统，中间件，数据库都有极大的不同，无法平滑升级，数据无法从 VCS 导出，然后导入到 vCSA ，当中涉及到太多利害关系了，光网络和数据库就够你喝一壶（ps:vCSA比VCS 部署和架构都简单，而且能省掉M$的License）虽然之前在Flings 上有大神做了一个 VCS to VCVA Converter 的转换程序，之后正式被官方集成生产——vCenter Server Appliance (VCSA) Migration Tool officially GAs w/vSphere 6.0 Update 2m 我的方式 VCS to VCVA Converter 很早之前我就做了实验去验证，那时候实验环境比较简单，所以试了两次后，便完成验证了。在接触到复杂的虚拟化环境后，我开始考虑到这个物件的不确定性了，每个环境的管理者的技术水平都不是同一水平的，因此环境变得不可捉摸，如果有别的物件如监控，备份的依赖 VCS ，那转换成 VCSA 就很可能发生不可预测的错误，转换失败虽然不会破坏 VCS 的数据，但转换过程需要把 VCS 关机 ，但做我们这一行，很忌讳服务器关机/重启，因为很可能就启动不了或者启动失败。整好，目前我管理的虚拟化环境VCS 5.5 有升级到 VCSA 的需求，而且环境巨复杂，简单的说一下： 有4个集群，有的集群多达 30 个 ESXI-HOST 主机，几乎是vSphere 5.5 的最高配置。 每个集群独立的 VDS (虚拟分布式交换机)，总 VDP （分布式端口组）超过 200 个 每个 VDS 都关联了两个上联口 总 VM 数量超过 1000 个 每个 VM 的网卡都挂载了一个 VDP （分布式端口组），可怕吧····· 因此我在寻求一种平滑升级的方式，尽量的、原生的，可持续的完成VCSA 接管 VCS 的ESXI、VM、分布式虚拟网络配置等。后来在 PowerCLI 上看到了可能 思路利用跑业务流量的双网卡冗余特点，编写脚本实现精准切换端口组 先部署 VCSA6.0（已部署） 在 VCSA 上创建与 VC一样的集群架构，以及分布式交换机的端口组一致（脚本保证一致性） 通过脚本控制 VDS (分布式端口组)-&gt; VSS (标准端口组)的精准切换（保证端口组的影响降到最低） 把 ESXI 注册到 VCSA 上，VM 绑定在 VSS，注册过程不受影响 通过脚本回切端口组（VSS -&gt; VDS） 迁移图示 特点除了第一步，其余步骤均是通过脚本实现以 ESXI 为单位逐台注册到 VCSA，随时可中断回滚，为了解决 VDS 与 VM 之间的关联关系，VM 先绑定在 VSS 上，脱离了对 VDS的影响。一切变更操作设计以保护VM链路不中断为原则；整个变更中，基本上是管理上的调整，不会改变ESXI既定的物理网络配置 难点因为涉及到 VM 网卡上的端口组配置变换，必须保证绝对的精准记录每个 VM 网卡上面的 连接的端口组名称是什么，新建的 VDP 的 VLAN 号必须要跟原来的端口组 VLAN 号一致。我的解决办法是，导出这些配置，然后根据导出的内容，在新建的 VSS 上创建相应的端口组，且端口组名称尽量还是要增加标识来区分，来维护全局唯一的规则，这样降低报错和变更风险。 风险正在变更的ESXI上负载的VM在切换端口组的时候可能会有1~2个丢包的影响，类似情况就是双线冗余的业务链路断开了一线，正在使用该链路的流量会从另一个冗余的链路过来。 PowerCLI 脚本需要在PowerCLI把新旧两个VC都Login上1234$Cred = get-credentialConnect-VIServer "old-VC-address" -Credential $Cred -SaveCredentials -WarningAction SilentlyContinue$Cred1 = get-credentialConnect-VIServer "new-VC-address" -Credential $Cred1 -SaveCredentials -WarningAction SilentlyContinue 公共参数1234#把之前导出的HOST-VM-PG-VMNIC-LIST.csv 导入到变量中---------这部分导入适用于需要从表获取信息配置的操作$xpath = split-path -parent $MyInvocation.MyCommand.Definition$CsvPath= "$xpath\HOST-VM-PG-VMNIC-LIST.csv"$vmlists = Import-Csv $CsvPath -encoding Default | ?&#123;$_.deploy -like "*Y*" -and $_.VMHOST -eq $vmhost&#125; -ErrorAction SilentlyContinue 生成 HOST-VM-PG-VMNIC-LIST靠人是记不住，也记不完的，所以要把目前的配置导出（VM、VMHOST、VMNAME、NICNAME、NICMAC、PGNAME、VLAN、VSSPG、VSSNIC 、VDSNIC、VDSNAME）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#导出指定 ESXI 主机的信息param($vmhost)$getvmhost = get-vmhost $vmhost -ErrorAction SilentlyContinue$getvds = $getvmhost | Get-VDSwitch$getcluster = $getvmhost | Get-cluster$getdc = $getvmhost | Get-Datacenter#获取 VDS 的端口组列表$getvdspg = $getvmhost | Get-VirtualPortGroup -Distributed#获取 VDS 的上联口$getvmnic = $getvds | Get-VMHostNetworkAdapter | ?&#123;$_.VMHOST -like $vmhost&#125;if($getvmnic.Count -eq 2)&#123;#获取 VDS 的两个上联口 $vdsnic = $getvmnic[0].name $vssnic = $getvmnic[1].name&#125;else&#123;#如果只有一个上联口，网络会中断的。 $vssnic = "none" $vdsnic = $getvmnic[0].name&#125;#获取每个 VM 的 NETINFOforeach($GETVM in $getvmhost | Get-vm)&#123;#遍历 ESXI 主机上的每个 VM foreach($GETVMNIC in $GETVM | Get-NetworkAdapter) &#123;#遍历 VM 上的每个 VNIC $VMname = $GETVM.name $nicname = $GETVMNIC.Name $nicmac = $GETVMNIC.MacAddress $pgname = $GETVMNIC.NetworkName $Newvsspg = "none" $PGVLAN = "none" if($getvdspg.name -contains $pgname) &#123;#判断 PG 是否是分布式端口组，如果是，则定义新建的对应的 VSS PG $Newvsspg = "VSS" +$GETVMNIC.NetworkName $PG = $getvdspg | ?&#123;$_.name -eq $pgname&#125; $PGVLAN = $PG.ExtensionData.Config.DefaultPortConfig.Vlan.VlanId &#125; #导出 $Y = "Y" $outlist = [PSCustomObject]@&#123; Deploy = $Y DC = $getdc.name Cluster = $getcluster.name VMHOST = $vmhost VMNAME = $VMname NICNAME = $nicname NICMAC = $nicmac PGNAME = $pgname VLAN = $PGVLAN VSSPG = $Newvsspg VSSNIC = $vssnic VDSNIC = $vdsnic VDSNAME = $getvds.name &#125; $outlist | Export-CSV -Path $CsvPath -Append -NoTypeInformation -encoding Default &#125;&#125; 在新的VC创建对应的VDS以及VDPG1234567891011121314151617181920212223242526#因为集群可配置项比较多，每人的要求都不尽想停，没写自动创建集群，需要在新的VC上手动创建Cluster。#新建VDSforeach($creatvds in $vmlists | Select-Object -Property DC,VDSNAME -Unique)&#123;##指定一下VDS的版本 $VER = "5.5.0" $DC = $creatvds.DC $VDS = $creatvds.VDSNAME $VDSinfo = Get-VDSwitch $VDS -ErrorAction SilentlyContinue if($VDSinfo -eq $null) &#123;#如果没有VDS则创建 $myDC = Get-Datacenter -Name $DC New-VDSwitch -Name $VDS -Location $myDC -NumUplinkPorts 2 -LinkDiscoveryProtocol "LLDP" -LinkDiscoveryProtocolOperation "Listen" -Version $VER -Confirm:$false -RunAsync | OUT-NULL write-host "$DC 创建 $VDS 成功。" -f green &#125; &#125;#获取现有的VDSPG清单$VDSPG = Get-VDPortgroup -VDSwitch "$VDSNAME" | Where &#123; $_.Name -NotMatch "-DVUplinks" &#125;#循环需要创建的VDPG清单foreach($creatvdspg in $vmlists | Select-Object -Property VDSNAME,VLAN,PGNAME -Unique)&#123; $VDS = $creatvdspg.VDSNAME $PG = $creatvdspg.PGNAME $VLAN = $creatvdspg.VLAN Get-VDSwitch -Name $VDS | New-VDPortgroup -Name $PG -NumPorts 8 -VLanId $VLAN -RunAsync | OUT-NULL write-host "$VDS 创建 $PG 成功。" &#125; 创建临时 VSW 标准虚拟交换机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#操作指定的ESXI主机$getvmhost = get-vmhost $vmhost -ErrorAction SilentlyContinue#临时的虚拟交换机的名称，如果冲突请修改后面的数字$vssw = "vSwitch2" $getvmhost | New-VirtualSwitch -Name $vssw | out-null"$vssw 创建成功"Start-Sleep -Seconds 1#获取相关对象 （已经创建的vsw，目前vsw所关联的nic，目前vds所关联的nic，目前vsw上已经存在的vpg）$getvsw = $getvmhost | Get-VirtualSwitch -Name $vssw$getvssvmnic = $getvsw | Get-VMHostNetworkAdapter -Physical$getvmnic = $getvmhost | Get-VDSwitch | Get-VMHostNetworkAdapter | ?&#123;$_.VMHOST -like $vmhost&#125;$getvspg = $getvmhost | Get-VirtualPortGroup -Standard#根据之前导出的配置表，在新建的VSS上创建响应的端口组newvsspgforeach($creatvsspg in $vmlists | Select-Object -Property Deploy,VMHOST,VLAN,VSSPG -Unique)&#123; $vlanid = $creatvsspg.VLAN $vsspg = $creatvsspg.VSSPG if($vsspg -eq "none") &#123;&#125; elseif($getvspg.name -contains $vsspg) &#123; "$vsspg 已存在,跳过" &#125; else &#123; $getvsw | New-VirtualPortGroup -Name $vsspg -VLanId $vlanid -confirm:$false | Out-Null "$vsspg 创建成功" &#125;&#125;if($getvssvmnic.count -eq 0)&#123;#判断如果VSS没有挂载VMNIC,移除VDS的VSSNIC出来 foreach($migratevmnic in $vmlists | Select-Object -Property Deploy,VMHOST,VSSNIC,VDSNIC,VDSNAME -Unique) &#123;#迁移VDS-VMNIC到VSS-VMNIC $VSSNIC = $migratevmnic.VSSNIC $VDSNIC = $migratevmnic.VDSNIC if($VSSNIC -eq "none" -or $VDSNIC -eq "none") &#123;"0"&#125; elseif($getvmnic.name -contains $VSSNIC -and $getvmnic.name -contains $VDSNIC) &#123;#必须两个 VMNIC 都在 VDS-UPLINK 中才能移除 VSSNIC,并挂载到 VSSW $getvmhost | Get-VMHostNetworkAdapter -Physical -Name $VSSNIC | Remove-VDSwitchPhysicalNetworkAdapter -confirm:$false $getvssnic = $getvmhost | Get-VMHostNetworkAdapter -Physical -Name $VSSNIC $getvsw | Add-VirtualSwitchPhysicalNetworkAdapter -VMHostPhysicalNic $getvssnic -confirm:$false &#125; elseif($getvmnic.name -notcontains $VSSNIC -and $getvmnic.name -contains $VDSNIC) &#123;#如已经移除则挂载 VSSNIC 到 VSSW $getvssnic = $getvmhost | Get-VMHostNetworkAdapter -Physical -Name $VSSNIC $getvsw | Add-VirtualSwitchPhysicalNetworkAdapter -VMHostPhysicalNic $getvssnic -confirm:$false &#125; &#125;&#125;else&#123; read-host "$vssw 已存在 $getvssvmnic "&#125; 重定向VM的NIC端口组至VSS端口组1234567891011foreach($vmlist in $vmlists | Select-Object -Property PGNAME,VSSPG -Unique)&#123; $PGNAME = $vmlist.PGNAME $VSSPG = $vmlist.VSSPG if($VSSPG -ne "none") &#123;#把该ESXI上的VDSPG迁移到VSSPG上, PG by PG $getvmhost | Get-VM | Get-NetworkAdapter | ?&#123;$_.NetworkName -eq $PGNAME&#125; | Set-NetworkAdapter -NetworkName $VSSPG -Confirm:$false -RunAsync | out-null "$getvmhost $PGNAME ==&gt; $VSSPG DONE." #这一步会把操作的ESXI-HOST 上所有关联到VDSPG的VM-NIC，重定向关联到VSSPG上 &#125;&#125; 移除/新建分布式交换机12345678910111213141516$VDSinfo = $vmlists | Select-Object -Property VDSNIC,VDSNAME -Unique$VDSNIC = $vdsinfo.VDSNIC$VDSNAME = $vdsinfo.VDSNAME$getvdsw = Get-VDSwitch $VDSNAMEif($getvds -ne "none")&#123;#如果还没有移除则 $getvdsw | Remove-VDSwitchVMHost -VMHost $getvmhost -Confirm:$false read-host "已移除VDS,确认再从VC中移除$vmhost 则按回车继续" Set-VMHost -VMHost $getvmhost -State "Disconnected" | out-null&#125;else&#123;#如果没有注册到新的VDS.. $getvdsw | Add-VDSwitchVMHost -VMHost $getvmhost $GETVMHOSTNIC = $getvmhost | Get-VMHostNetworkAdapter -Physical -Name $VDSNIC $getvdsw | Add-VDSwitchPhysicalNetworkAdapter -VMHostNetworkAdapter $GETVMHOSTNIC -Confirm:$false&#125; 添加ESXI到指定的位置1234567891011if(!$getvmhost -eq $null)&#123;#使用ESXI的凭据 添加到新的VC指定的位置 $users="root" $password="password" $Datacenter = "Datacenter" $Cluster = "Cluster" read-host "按回车确认添加 $vmhost 到 $Datacenter 集群 $Cluster 吗?! 请等待添加完成后再执行任务4 " Add-VMHost -Name $vmhost -Location (Get-Datacenter $Datacenter | get-cluster $Cluster) -User $users -Password $password -force:$true -RunAsync -Confirm:$false | Out-Null Start-Sleep -Seconds 30 #完成后最好等个 30 秒。因为新的 ESXI 加入集群要初始化 HA 状态&#125; 重定向VM的NIC端口组至VDS端口组12345678910111213141516171819202122232425262728293031323334353637383940414243foreach($vmlist in $vmlists | Select-Object -Property PGNAME,VSSPG,VSSNIC,VDSNAME -Unique)&#123; $PGNAME = $vmlist.PGNAME $VSSPG = $vmlist.VSSPG $VSSNIC = $vmlist.VSSNIC $VDSNAME = $vmlist.VDSNAME #把该ESXI上的VSSPG迁移到VDSPG上,按PG来 if($VSSPG -ne "none") &#123; $getvmhost | Get-VM |Get-NetworkAdapter | ?&#123;$_.NetworkName -eq $VSSPG&#125; | Set-NetworkAdapter -NetworkName $PGNAME -Confirm:$false -RunAsync | out-null "$getvmhost $VSSPG ==&gt; $PGNAME DONE." &#125;&#125;Start-Sleep -Seconds 3#检查VSW上还有没有没被处理的VM$vssw = "vSwitch2" $getvdsw = Get-VDSwitch $VDSNAME$getvssw = Get-VirtualSwitch $getvmhost -Name $vssw$vspgnum = $getvssw | Get-VirtualPortGroup$vspgvmnum = $getvssw | Get-VM$vmnum = $vspgvmnum.count" $vssw 上共有 $vmnum 个VM ,如果存在VM,请检查"read-host "按回车确认移除VSS,并把$VSSNIC 添加至 VDS $VDSNAME"if($vspgvmnum.Count -eq 0)&#123;#只有VSSPG上没有挂载VM,才可以移除VSSPG,归还VMNIC给VDS Remove-VirtualSwitch -VirtualSwitch $getvssw -Confirm:$false $GETVMHOSTNIC = $getvmhost | Get-VMHostNetworkAdapter -Physical -Name $VSSNIC $getvdsw | Add-VDSwitchPhysicalNetworkAdapter -VMHostNetworkAdapter $GETVMHOSTNIC -Confirm:$false "移除VSS, $VSSNIC 添加至 VDS $VDSNAME DONE"&#125;else&#123; "$vssw 上连接了 $vmnum 个VM ,请检查并移除后继续" read-host $vspgvmnum = $getvssw | Get-VM if($vspgvmnum.Count -eq 0) &#123;#直到VSSPG上没有挂载VM Remove-VirtualSwitch -VirtualSwitch $getvssw -Confirm:$false $GETVMHOSTNIC = $getvmhost | Get-VMHostNetworkAdapter -Physical -Name $VSSNIC $getvdsw | Add-VDSwitchPhysicalNetworkAdapter -VMHostNetworkAdapter $GETVMHOSTNIC -Confirm:$false "移除VSS, $VSSNIC 添加至 VDS $VDSNAME DONE" &#125;&#125; 简单新建代替会死吗？当我提出这个方案的时候，很多人问我的一个问题。其实并不会死，指示会让你麻烦死。首先，肯定不能直接在集群里移除ESXI，你只能断开连接这个ESXI其次，未从 VDS 移除 ESXI ，ESXI 会残留这原来的VDS信息，直接去注册到别的 VDS ，你需要替换对应的端口组，但很不幸的告诉你，这个时候你已经无法看到VM的网卡原来关联的端口组名称是什么了，这会让你的运维带来困境。万一你选错关联的端口组。VM 的网络会中断。 运行好好的为什么升级？通过从 VC5.5 升级到使用 VCSA6.0 可获得以下收益。 支持更大的集群规模，支持 64 个主机组成集群 为后续ESXi5.5 升级到 ESXi6.0 夯实基础 节约额外的授权费用（VC需要Windows，sql server授权，VCSA则不需要） 节省独占物理主机的运营成本 部署 VCSA 比 VC 要更快 日常运行效率更高 可获得虚拟机的高可用，数据保护，中高端存储的性能优势 灵活的增配VC资源 两个VC共享验证凭据，SSO单点登陆]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>PowerCLI</tag>
        <tag>vCenter</tag>
        <tag>vCSA</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Powershell 远程管理服务器]]></title>
    <url>%2F2015%2F11%2F18%2Fpowershell-mag-remote-host%2F</url>
    <content type="text"><![CDATA[管理环境-条件 远程服务器（客户端） 默认情况下，PowerShell 禁止 PowerShell 脚本在 Windows 系统中执行。需要修改策略来解除。 PowerShell 管理员模式下执行： 1Set-ExecutionPolicy bypass 启用远程处理模式 1Enable-PSRemoting -force 管理服务器（管理端） 添加信任列表，PowerShell 管理员模式下执行： 1Set-Item WSMan:\localhost\Client\TrustedHosts -Value * -force 扩展远程操作主要依赖几个Session（会话）命令和Invoke-Command命令来进行。总结下 Enter-PSSession 远程交互式会话 这个场景一般用于手动进行远程操作，输入命令，查看结果。方法很简单。进入交互式会话的命令是Enter-PSSession，退出时键入Exit-PSSession或者exit都可以。远程交互式操作期间，输入的命令在远程计算机上运行，就像直接在远程计算机上输入并执行这些命令一样。期间所定义的变量和命令的执行结果在退出交互式会话之后不再可用。 New-pssession 建立会话执行一次性操作 这种在本地计算机与远程计算机上建立一个临时会话。将脚本块或者脚本文件的内容发送到远程计算机执行，并将结果发回本地计算机。这种方法执行效率很高，是PowerShell推荐的执行远程命令的方法。除非需要在会话中共享数据，否则建议使用该使用方法。注意，会话数量是有限制的，用完务必释放会话。 Invoke-Command 命令/脚本在命名会话中执行 用 New-pssession 建立会话并保存到一个变量中，然后在Invoke-Command中指定会话使用该变量。可将执行结果赋予到新的变量中 格式： 1$sub = Invoke-Command -Session $session1 -ScriptBlock &#123;dir c:\&#125; 其它PowerShell 在网络处理方面有诸多限制。比如 PowerShell 不能在远程机器上显示界面，即使是有界面的程序，也只能在后台运行。]]></content>
      <categories>
        <category>Powershell</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟化是什么]]></title>
    <url>%2F2014%2F08%2F08%2Fvirtualization-evo%2F</url>
    <content type="text"><![CDATA[引用WIKI 在计算机技术中，虚拟化（技术）或虚拟技术（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源（CPU、内存、磁盘空间、网络适配器等），予以抽象、转换后呈现出来并可供分区、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。 虚拟化不是一个新技术，在上个世纪60年代就已经诞生了，真正在X86架构下广泛应用应该是在本世纪初由VMWare公司推出企业级vSphere 虚拟化软件产品，配合Intel 等厂商随着工艺的不断进步升级，物理服务器可以运行多个虚拟机，每个虚拟机可以负载不同的程序，极大的提高了物理服务器的资源利用率，同时也保持了程序之间隔离性。 虚拟化技术解决了什么问题虚拟化技术在那些领域中得到广泛应用选择虚拟化的思考点极大的提高资源的利用率缩减了企业的IT成本创新、先进是企业在竞争中重要的决胜关键点]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于这里]]></title>
    <url>%2F2014%2F07%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[记录我在IT技术的道路上探索实践中的点点滴滴目前专注方向-2017VMWare：vSphere/Horizon 安装、部署、规划、设计、管理、自动化运维 开发：Powershell、PowerCLI、Pyhton IDC基础设施：数据中心、机房机柜、服务器设备 数据管理：数据存储/管理/备份/复制/重删/压缩 扩展：基于VMWare环境的网络/存储/备份/灾备 云计算工程技术：虚拟化技术、SDS、SDN、CMP、IAAS、PAAS]]></content>
      <categories>
        <category>随手杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
</search>
